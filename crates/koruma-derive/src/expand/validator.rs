use heck::{ToSnakeCase, ToUpperCamelCase};
#[cfg(feature = "showcase")]
use koruma_derive_core::find_showcase_attr;
use koruma_derive_core::{find_value_field, option_inner_type};
use proc_macro2::TokenStream as TokenStream2;
use quote::{format_ident, quote};
use syn::{Fields, GenericParam, Ident, ItemStruct, parse_quote};

/// Core expansion logic for the `#[validator]` attribute macro.
///
/// Takes a parsed struct and returns the expanded TokenStream.
pub fn expand_validator(mut input: ItemStruct) -> Result<TokenStream2, syn::Error> {
    let struct_name = &input.ident;
    let builder_name = format_ident!("{}Builder", struct_name);

    // Check if the struct has generics
    let has_generics = !input.generics.params.is_empty();

    // Parse showcase attribute if present (only when feature enabled)
    #[cfg(feature = "showcase")]
    let showcase_attr = find_showcase_attr(&input);

    // Find the field marked with #[koruma(value)]
    let (value_field_name, value_field_type) = find_value_field(&input).ok_or_else(|| {
        syn::Error::new_spanned(
            &input,
            "koruma::validator requires a field marked with #[koruma(value)].\n\
             Example:\n\
             #[koruma(value)]\n\
             actual: Option<i32>",
        )
    })?;

    // Extract the inner type from Option<T>
    let inner_type = option_inner_type(&value_field_type).unwrap_or(&value_field_type);

    // Add #[derive(bon::Builder)] to the existing attributes
    let builder_attr: syn::Attribute = parse_quote!(#[derive(koruma::bon::Builder)]);
    input.attrs.insert(0, builder_attr);

    // Remove #[koruma(value)] and #[showcase(...)] from attributes
    input.attrs.retain(|attr| !attr.path().is_ident("showcase"));

    // Remove #[koruma(value)] from the field so bon doesn't see it
    if let Fields::Named(ref mut fields) = input.fields {
        for field in &mut fields.named {
            field.attrs.retain(|attr| {
                if attr.path().is_ident("koruma")
                    && let Ok(ident) = attr.parse_args::<Ident>()
                {
                    return ident != "value";
                }

                true
            });
        }
    }

    // Generate the module name that bon creates (snake_case of struct name + _builder)
    let module_name = format_ident!("{}_builder", struct_name.to_string().to_snake_case());

    // Generate the associated type name (PascalCase of field name) and Set wrapper
    let value_pascal = value_field_name.to_string().to_upper_camel_case();
    let value_assoc_type = format_ident!("{}", value_pascal);
    let set_value_type = format_ident!("Set{}", value_pascal);

    let with_value_impl = if has_generics {
        // For generic validators, the builder is Builder<T, S> (type param first, then state)
        // Use the actual field type (inner_type) for the value parameter
        //
        // We need to propagate the bounds from the original struct's generics.
        // The builder has form: StructBuilder<T, S> where T has the original bounds and S is builder state.

        // Extract just the type parameter names (without bounds) for use in type position
        let type_param_names: Vec<_> = input
            .generics
            .params
            .iter()
            .filter_map(|p| match p {
                GenericParam::Type(t) => Some(&t.ident),
                _ => None,
            })
            .collect();

        // Extract bounds from the generic params to put in where clause
        let type_param_bounds: Vec<_> = input
            .generics
            .params
            .iter()
            .filter_map(|p| match p {
                GenericParam::Type(t) if !t.bounds.is_empty() => {
                    let ident = &t.ident;
                    let bounds = &t.bounds;
                    Some(quote! { #ident: #bounds })
                },
                _ => None,
            })
            .collect();

        let where_clause = &input.generics.where_clause;

        // Build where predicates: type param bounds + original where clause + S::Value: IsUnset
        let where_predicates = {
            let mut predicates = type_param_bounds;
            if let Some(wc) = where_clause {
                for pred in &wc.predicates {
                    predicates.push(quote! { #pred });
                }
            }
            predicates.push(quote! { S::#value_assoc_type: koruma::bon::IsUnset });
            predicates
        };

        quote! {
            impl<#(#type_param_names,)* S: #module_name::State> #builder_name<#(#type_param_names,)* S>
            where
                #(#where_predicates),*
            {
                /// Sets the value field. This is auto-generated by `#[koruma::validator]`.
                pub fn with_value(self, value: #inner_type) -> #builder_name<#(#type_param_names,)* #module_name::#set_value_type<S>> {
                    self.#value_field_name(value)
                }
            }
        }
    } else {
        quote! {
            impl<S: #module_name::State> #builder_name<S>
            where
                S::#value_assoc_type: koruma::bon::IsUnset,
            {
                /// Sets the value field. This is auto-generated by `#[koruma::validator]`.
                pub fn with_value(self, value: #inner_type) -> #builder_name<#module_name::#set_value_type<S>> {
                    self.#value_field_name(value)
                }
            }
        }
    };

    // Generate showcase registration if the attribute is present
    #[cfg(feature = "showcase")]
    let showcase_registration = if let Some(showcase) = showcase_attr {
        let name = &showcase.name;
        let description = &showcase.description;
        let create_closure = &showcase.create;
        let input_type_tokens = if let Some(ref it) = showcase.input_type {
            quote! { ::koruma::showcase::InputType::#it }
        } else {
            quote! { ::koruma::showcase::InputType::Text }
        };

        // Extract generics from the struct
        let (impl_generics, type_generics, _where_clause) = input.generics.split_for_impl();

        // Extract bounds from the generic params for the where clause
        let mut where_predicates = Vec::new();
        for param in input.generics.params.iter() {
            if let GenericParam::Type(t) = param {
                let ident = &t.ident;
                // Add all existing bounds plus Send + Sync + Clone + 'static
                // If no existing bounds, don't include the leading `+`
                if t.bounds.is_empty() {
                    where_predicates.push(quote! { #ident: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'static });
                } else {
                    let bounds = &t.bounds;
                    where_predicates.push(quote! { #ident: #bounds + ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'static });
                }
            }
        }
        // Add Self: Display bound
        where_predicates.push(quote! { Self: ::std::fmt::Display });

        let combined_where = if where_predicates.is_empty() {
            quote! {}
        } else {
            quote! { where #(#where_predicates),* }
        };

        quote! {
            // DynValidator is implemented by validators that have Validate + Display impls
            #[cfg(feature = "showcase")]
            impl #impl_generics ::koruma::showcase::DynValidator for #struct_name #type_generics
            #combined_where
            {
                fn is_valid(&self) -> bool {
                    ::koruma::Validate::validate(self, &self.#value_field_name)
                }

                fn display_string(&self) -> String {
                    #[cfg(feature = "fmt")]
                    { ::std::string::ToString::to_string(self) }
                    #[cfg(not(feature = "fmt"))]
                    { "(fmt feature required)".to_string() }
                }

                fn fluent_string(&self) -> String {
                    #[cfg(feature = "fluent")]
                    {
                        use ::es_fluent::ToFluentString as _;
                        self.to_fluent_string()
                    }
                    #[cfg(not(feature = "fluent"))]
                    { "(fluent feature required)".to_string() }
                }
            }

            ::koruma::inventory::submit! {
                ::koruma::showcase::ValidatorShowcase {
                    name: #name,
                    description: #description,
                    input_type: #input_type_tokens,
                    create_validator: |input: &str| -> Box<dyn ::koruma::showcase::DynValidator> {
                        Box::new((#create_closure)(input))
                    },
                }
            }
        }
    } else {
        quote! {}
    };

    #[cfg(not(feature = "showcase"))]
    let showcase_registration = quote! {};

    Ok(quote! {
        #input

        #with_value_impl

        #showcase_registration
    })
}
